name: Deploy to OpenStack VM

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
          - production

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install SSH Key
        uses: shimataro/ssh-key-action@v2
        with:
          key: ${{ secrets.SSH_KEY }}
          known_hosts: 'just-a-placeholder-so-we-dont-fail'
          if_key_exists: replace

      - name: Deploy to VM
        env:
          SSH_HOST: ${{ secrets.SSH_HOST }}
          SSH_USER: ${{ secrets.SSH_USER }}
          SSH_PROXY_HOST: ${{ secrets.SSH_PROXY_HOST }}
          SSH_PROXY_USER: ${{ secrets.SSH_PROXY_USER }}
          DEPLOY_PATH: ${{ vars.DEPLOY_PATH }}
          # Secrets to be injected into .env
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          SECRET_KEY: ${{ secrets.SECRET_KEY }}
          DOMAIN_NAME: ${{ vars.DOMAIN_NAME }}
          # Optional: Add other secrets here
          JUMP_HOST_PASSWORD: ${{ secrets.JUMP_HOST_PASSWORD }}
        run: |
          # Install sshpass
          sudo apt-get update
          sudo apt-get install -y sshpass

          # Configure SSH ProxyJump
          mkdir -p ~/.ssh
          
          # Handle IPv6 for ProxyCommand
          if [[ "$SSH_HOST" == *":"* ]]; then
            PROXY_TARGET="[%h]:%p"
          else
            PROXY_TARGET="%h:%p"
          fi

          cat << EOF > ~/.ssh/config
          Host jump
            HostName $SSH_PROXY_HOST
            User $SSH_PROXY_USER
            StrictHostKeyChecking no
          
          Host target
            HostName $SSH_HOST
            User $SSH_USER
            ProxyCommand sshpass -e ssh -W $PROXY_TARGET -o StrictHostKeyChecking=no $SSH_PROXY_USER@$SSH_PROXY_HOST
            StrictHostKeyChecking no
          EOF
          
          # Export SSHPASS for sshpass to use
          export SSHPASS=$JUMP_HOST_PASSWORD
          chmod 600 ~/.ssh/config
          
          echo "Deploying to target ($SSH_HOST) via jump ($SSH_PROXY_HOST)..."
          
          # Create deployment script
          cat << 'EOF' > deploy_script.sh
          set -e
          
          # Navigate to deployment directory or clone if it doesn't exist
          if [ ! -d "$DEPLOY_PATH/.git" ]; then
            echo "Repository not found in $DEPLOY_PATH. Cloning..."
            # Ensure parent directory exists (requires permissions)
            mkdir -p "$DEPLOY_PATH"
            # Clone the repository
            git clone https://github.com/${{ github.repository }}.git "$DEPLOY_PATH"
            cd "$DEPLOY_PATH"
          else
            cd "$DEPLOY_PATH"
            # Pull latest code
            git fetch origin main
            git reset --hard origin/main
          fi
          
          # Create/Update .env file
          echo "Creating .env file..."
          cat << ENV > .env
          # Generated by GitHub Actions
          ENVIRONMENT=production
          DEBUG=false
          
          # Secrets
          OPENAI_API_KEY="$OPENAI_API_KEY"
          POSTGRES_PASSWORD="$POSTGRES_PASSWORD"
          SECRET_KEY="$SECRET_KEY"
          
          # Database
          POSTGRES_USER=retrievai
          POSTGRES_DB=retrievai
          DATABASE_URL="postgresql+asyncpg://retrievai:$POSTGRES_PASSWORD@postgres:5432/retrievai"
          
          # Redis
          REDIS_URL=redis://redis:6379/0
          
          # Chroma
          CHROMA_HOST=chromadb
          CHROMA_PORT=8000
          # IMPORTANT: Ensure CHROMA_DB_PATH is set in your shell or .bashrc if not using default
          CHROMA_DB_PATH=/srv/retrievai-data/chromadb 
          
          # Frontend
          VITE_API_URL=/api
          ENV
          
          # Secure .env
          chmod 600 .env
          
          # Update NGINX config if needed
          if [ -f nginx.conf ]; then
            echo "Updating NGINX config..."
            # Substitute DOMAIN_NAME in nginx.conf
            sed -i "s/\${DOMAIN_NAME}/$DOMAIN_NAME/g" nginx.conf
            
            # Remove all existing sites to prevent conflicts
            sudo rm -f /etc/nginx/sites-enabled/*
            
            sudo cp nginx.conf /etc/nginx/sites-available/retrievai
            sudo ln -sf /etc/nginx/sites-available/retrievai /etc/nginx/sites-enabled/
            sudo nginx -t && sudo systemctl reload nginx || echo "NGINX reload failed, check config"
          fi
          
          # Deploy with Docker Compose
          echo "Starting services..."
          docker compose -f docker-compose.prod.yml up -d --build --remove-orphans
          
          # Wait for DB
          echo "Waiting for database..."
          sleep 10
          
          # Run Migrations
          echo "Running migrations..."
          docker compose -f docker-compose.prod.yml run --rm backend uv run alembic upgrade head
          
          # Run Data Migrations (Idempotent)
          # echo "Running data migrations..."
          # docker compose -f docker-compose.prod.yml run --rm backend python migration_scripts/migrate_settings.py
          
          echo "Deployment complete!"
          EOF
          
          # Execute script on VM
          # We pass the secrets as env vars to the ssh command so they are available in the script
          # Execute script on VM
          # We connect to 'target' which uses the ~/.ssh/config we created above
          ssh target \
            "OPENAI_API_KEY='$OPENAI_API_KEY' \
             POSTGRES_PASSWORD='$POSTGRES_PASSWORD' \
             SECRET_KEY='$SECRET_KEY' \
             DEPLOY_PATH='$DEPLOY_PATH' \
             DOMAIN_NAME='$DOMAIN_NAME' \
             bash -s" < deploy_script.sh
